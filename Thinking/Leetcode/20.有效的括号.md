## 题目描述

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。有效字符串需满足：

- 左括号必须用相同类型的右括号闭合。
- 左括号必须以正确的顺序闭合。
- 注意空字符串可被认为是有效字符串。

```
示例 1:					示例 2:
输入: "()"				输入: "()[]{}"
输出: true				输出: true
示例 3:					示例 4:
输入: "(]"				输入: "([)]"
输出: false				输出: false
示例 5:
输入: "{[]}"
输出: true
```

## 题解

### 1. 递归

​	简单题，使用堆栈实现，当遇到左括号存入堆栈，遇到右括号取出并比较，如果不是同类括号就返回失败。遍历结束时如果堆栈还有括号说明匹配失败，否则成功。

​	在添加和取出匹配括号时使用了哈希表，以括号的ascii作为key，往一对括号里存入相同的val，再比较时只用继续向哈希表查找该key，根据两者的val是否相同即可得到是否匹配。如果不使用哈希表，直接向堆栈存入括号的ascii码，那么取出时需要对每个括号进行一次匹配和情况的处理，开销和代码编写都非常繁琐。

```c
#include<stdio.h>
#include<stdlib.h>
#include"../macro.h"
#include"../string.h"

#define TYPEC int
#include"../array.h"

int isValid(char * s){
    int hash[128]={0};
	hash['('] = hash[')'] = 1;
	hash['['] = hash[']'] = 2;
	hash['{'] = hash['}'] = 3;
	
	int num = str_len(s);
	if(!num)   return 1;
	Stack *stack = stack_init(num);
	for(int i = 0 ;i < num ;i++){
		if(s[i] == ')' || s[i] == ']' || s[i] == '}'){
			if(stack_next(stack) != hash[s[i]])
				return 0;
			stack_remove(stack,NULL);
		}else
			stack_add(stack,hash[s[i]]);
	}
	if(stack_size(stack))  return 0;
	return 1;
}
```

### 2. 哈希优化

​	题解1中可以看到使用堆栈存放，判断右括号，匹配左右括号，查询堆栈数量四个算法(广义)。其中1，4都是堆栈内部操作，直接API调用，没有什么优化的空间。但是2，3都还有一定的优化空间。

​	先说2，判断右括号，本体里右括号需要连续进行==判断，三个其实开销还可以接受，但如果数量继续增大，每个字符的判断的开销就比较大了，为了解决这情况，我们可以对其进行优化。思考一下可以发现这种情况其实就是查找，如本题就是查找`s[i]`是否存在`{'}',']',')'}`中，仅查找的操作往往可以使用哈希进行优化，其中添加到哈希表复杂度`O(n)`，查找复杂度`O(1)`，只要有多次查找，使用哈希表的时间就优于遍历。此外，这里哈希的val仅代表是否查找到，因此会有多个括号的key对应一个val(代表查找到)。

​	再说3匹配左右括号，可以看到题解1中已经使用了哈希表来加快匹配，哈希表本质是添加一个key-val的映射，同时支持常数级查找。假设AB俩个括号要进行比较，那么首先要在左括号中搜索A来确定处理代码，确定完后又需要在右括号中搜索B，来确定是否匹配。即使用了两个遍历查找，两个时间复杂度都取决于括号的种类。而题解1中之所以哈希表更快，只因为在存放A之前建立了`asciiA-val`映射并存放A，比较的时候又对B建立`asciiB-val`映射得到valB，而我们的哈希映射使得一对括号的val相等，且建立映射时间是常数级的，因此会更快。

​	那么3还有没有优化的地方，有的，那就是我们可以直接取消B的映射建立，这是因为题目对AB(左右括号)的要求不对称，仅要求A(左括号)先存入，然后取出A和B(右括号)比较，而没有要求取出B和A比较，这就代表B不会被存放不需要进入哈希表，也即被处理前不需经历映射。那么我们在比较AB时怎么取消B的映射？这就可以让A直接映射到B，即修改映射为`asciiA-asciiB`。这样可以减少一次B的映射，略微减少了处理时间。

​	3也优化了，还有没有可以优化的地方？有的，可以对2，3同时优化，先前说过可以将建立`asciiA-asciiB`的优化，那么也完全可以建立`asciiB-asciiA`的映射，存入A时不需要映射，比较时对B进行映射。这么做有什么好处?可以看看2，我们刚好用一个哈希表实现了2，3所需的优化，因为3的映射建立，所以2可直接在哈希表中查找key，此时返回的val实际上是asciiA，但同样代表已查找到。

​	对3的优化进行抽象提取，可以总结出如果需要比较AB是否符合某类关系，而且只有遇到某类数才会比较时，比如只有遇到B才会拿A和B进行比较，而遇到A就不会和B进行比较。此时就可以对A建立哈希表，并且建立映射`A-B`，往后遇到B便可直接和A的映射进行比较，节省一定内存访问开销。但如果AB性质基本一样，如遇到B也会和A进行比较的话，那么需要对两者都建立映射如`A-C`,`B-C`，比较时同时比较两者的映射值是否一样。

```c
int isValid(char * s){
    int hash[128]={0};
	hash[')'] = '(';
	hash[']'] = '[';
	hash['}'] = '{';
	
	int num = str_len(s);
	if(!num)   return 1;
	Stack *stack = stack_init(num);
	for(int i = 0 ,tmp;i < num ;i++){
		if(tmp = hash[s[i]]){
			if(stack_next(stack) != tmp)
				return 0;
			stack_remove(stack,NULL);
		}else
			stack_add(stack,s[i]);
	}
	if(stack_size(stack))  return 0;
	return 1;
}
```

