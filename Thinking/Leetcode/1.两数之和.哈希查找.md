## 题目介绍

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

示例:

```
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```

## 题解

### 1.暴力法

暴力法很简单，遍历数组，对数组中每个数再次遍历数组查找对应的数。时间复杂度`O(n*n)=O(n^2)`

### 2.哈希查找

暴力法有个明显优化点就是查找算法，因此使用哈希查找进行优化。该优化为`直接算法优化`，将数组数据存于哈希表中，从而将遍历查找优化为`O(1)`的哈希查找。时间复杂度分为存入哈希表的`O(n)`与遍历数组的`O(n)`之和，即为`O(n+n)=O(n)`。空间复杂度为`O(n)`。类似还有优化为二叉搜索，但这需要对数组排序，同时需要保存原数组索引作为题目输出，因此实现较麻烦且复杂度比哈希查找要高。

### 3. 哈希查找优化

哈希查找成功将复杂度变成`O(n)`,但其增加了`O(n)`的空间复杂度。为了再优化两个复杂度，可以从哈希表的数据存储过程入手。在哈希查找中，每次查找的查找对象数据都一直，也即`直接算法优化`中的相同IO。优化空间需要尽量减少存储的数据量，而在`O(n)`以上的时间复杂度查找算法中，更少的数据量同时也可以优化时间复杂度。该题需要发现两个输出值有着这样一种关系：只要题目两个输出值存在，不论以哪种顺序遍历，当遍历到后面的值时，前面的值必然已经被添加到存储中。此时就可以查找到前面的值得到题目输出。

当多个对象具有上述关系时，在遍历时就可利用该方法优化空间复杂度，无需先存储全部数据再处理。

## 最终代码

```c
#include"../macro.h"
#include"../hash.h"

int* twoSum(int* nums, int numsSize, int target, int* returnSize) 
{
    if(numsSize<2)  goto FAILED;
    
    *returnSize =2;

	int *ret=calloc(sizeof(int),2);
	int max = 0;
    
    /* 遍历得到最大绝对值作为哈希表长度初始化哈希表 */ 
	for(int i=0,tmp;i<numsSize;i++){
		tmp = nums[i]<0?-nums[i]:nums[i];
		tmp = max(tmp,target);
		max = max(tmp,max);
	}
    orihash *hash = orihash_init(max);
    
    for(int i=0,tmp;i<numsSize;i++){
    	tmp = target - nums[i];
    	if(orihash_find(hash,tmp,ret)){  //ret为输出的第一个坐标索引值 
    		ret[1] = i;
    		return ret;
		}
		else if(orihash_add(hash,nums[i],i)){    //将坐标索引值作为键值存储                 
            prt(Error:Add Hashtable Fail);
            break;
        }
	}
FAILED:
	*returnSize = 0;
	return NULL;
}
```

