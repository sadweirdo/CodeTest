## 题目描述

给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

```
示例 1:
给定 nums = [3,2,2,3], val = 3,
函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。

示例 2:
给定 nums = [0,1,2,2,3,0,4,2], val = 2,
函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。
```

## 题解

### 1. 快慢双指针

​	该题解和26题题解一致，使用快指针遍历数组，使用慢指针重新构建数组元素以便返回。在本题就是检测该值是否为需要去除的val，如果不是就将其填入慢指针位置，并递增慢指针，遍历结束慢指针即代表有效元素，可直接返回。

​	快慢指针的特点是不论数据怎样，返回数组的有效元素都是由慢指针构建起来的，即每个元素都是向慢指针赋值而得到的。要不使用额外空间下使用快慢指针，需要保证快指针遍历时已经遍历过的数据将不再被使用，而被使用的始终是慢指针构建的数据，因为快指针始终比慢指针要快(至少一致)，因此只要满足上述一点即可满足不适用额外空间。本题和26题之所以能用快慢指针也是因为如此。

### 2. 头尾双指针

​	本题相较26题，通常情况下需要删除的元素会较少，因此快慢双指针重新构建数组的处理次数会比26题多少许多，可以使用头尾双指针来加快效率。

​	头尾双指针即使用头指针遍历，当遍历到相同的val值元素时，将尾指针元素值赋值给头指针该元素，同时递减尾指针。为了避免尾指针元素也是val值，赋值时头指针并不增加，仅在头指针元素不为val时增加头指针。以`head<=tail`作为循环条件，当循环结束时head即为数组的有效元素。

​	头尾双指针需要A变量保存遍历元素值，B变量保存遍历元素索引，C变量保存尾指针，D变量保存有效数据数量。AB都可以用head指针表示，C变量即tail指针，而D变量用两个指针中哪一个表示都可以，head更方便，因此整个算法只需要两个指针作为变量。另外`head<=tail`的循环条件虽然是本题需要，但类似这样的形式其实也是头尾双指针常见的遍历条件。