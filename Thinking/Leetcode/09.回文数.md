## 题目要求

判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

```
示例 1:
输入: 121
输出: true
示例 2:
输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
示例 3:
输入: 10
输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。
```


进阶:你能不将整数转为字符串来解决这个问题吗？

## 题解

### 1. 直接法

​	简单题的直接法都很简单，即使限制32位环境也可用之前的`7.整数反转`再比较直接得到

### 2. 反转比较

​	该算法反转一半的数作为一变量的值，此时原变量也已经只有原先一半位数，再和新变量进行比较判断是否为回文数。该算法有意思的地方在于对反转结束的判断条件，利用俩变量的大小进行判断。有惊喜的地方在于结尾同时进行的奇偶回文数判断，难点在于如何确定算法包含了所有情况。

​	拿`ABC[]DEF`(`[]`代表奇偶)来说，我们用`m`表示原变量，`n`表示新变量。俩变量的变化如下：$m：ABC[\ ]DEF\rightarrow ABC[\ ]DE ... \rightarrow ABC$。$n: 0\rightarrow F ...\rightarrow FED[\ ]$。初始环境下`m>n`。我们就通过这个初始条件的改变作为基准进行一半变量反转的判断。

​	因为`A`始终不为0，因此只有n的位数大于m时才有可能出现`n>=m`。我们关注的是不论奇偶位数数字，只要是回文数则一定且仅有`ABC=FED`，先来看看偶函数，因为刚好可以对半分，可以很容易得出`n==m`这样的回文数判断条件，当`n = FED`时会有`m>n`、`m=n`、`m<n`三种情况，`m>n`时会继续反转，不可能再满足回文数条件，后两者会跳出反转循环，通过回文数判断筛选出回文数。

​	再来看看奇数，因为要改变初始条件必须满足n的位数大于m，所以只有`n=FED[]`,`m=ABC`，此时仍会有`m>n`、`m=n`、`m<n`三种情况，这是因为`F/E/D/[]`都可能等于0，若要满足`ABC=FED`，也可以很快得出`n%10==m`回文数判断条件。可以看出仅有`m<n`中的部分情况会满足回文数要求。而`m=n`情况只在`F=0`下才能出现`ED[]=ABC`,此时若还要满足`FED=ABC`，则`FED=ED[]`，`FED = EDD`最后得到`DDD=DDD=EEE=FFF=0`,因此除了数字0，`m=n`不满足回文数。至于`m>n`则会继续反转，也不可能再满足回文数条件。

​	现在已经得到了奇偶位数下各自的判断条件，这时其实已经可以先判断奇偶位数，再使用各自判断算法来判断回文数，但这里还可以继续优化成一个判断式子。上文很明显奇位下的条件简单，但对m,n的分析反而复杂，这也是为了最后进行的同时判断。同时判断很简单，将两个判断式用或运算连起来即可，`n==m || n%10==m`，如果说如何想到这样的优化，目前也只能说需要有心优化且不怕累。公式给出来，我们需要做的是排除额外的情况，对于偶数来说，要排除`m%10==n`，这很明显只会发生在`m>n`条件下，多位情况下此时`m=AB,n=FEDC,n%10=FED`，很明显当`F=0`时有可能发生，又因为`F`与`A`相对，所以`F=0`的数不可能为回文数。这里还有一个有意思的现象时若数字只有两位，则`m=0,n=BA,n%10=B`，此时`B`与`A`相对，若`B=0`就会满足`n%10==m`的判断，这和多位实际是一个道理，即数字最后一位数为0在偶数位下可能会满足`n%10==m`的判断条件，又因为偶数位数字最后一位为0和偶数位的回文数是两个不相干的集合，因此我们可以直接将偶数位数字最后一位为0的数字判断为非回文数。

​	对于奇数位来说，要排除`m==n`造成的干扰，前面已经讨论满足`m==n`奇位数数字中除了0之外没有回文数，因此我们只需要找到满足`m==n`的关键条件，看看该条件集合与奇位数回文数的集合是否相干，若不相干直接排除即可完成干扰的排除。而条件也在上文提及，刚好也是最后一位数字要为0，结合偶数位条件，我们得到了最终的排除干扰的判断`x%10==0 && x!=0 `。

​	最后给这篇进行一个不入流不保证对错的数学抽象，逻辑真的太差了，需要好好补补。

- 奇偶位数本身为一集合和条件A,B，两个判断条件分别是集合和条件M,N，回文数=$(A\cap M )\cup (B\cap N)$，但判断条件让$(A\cap(M\cup N))\cup(B\cap(M\cup N))$
- 我们需要各自的条件PQ使得(A&& (M || N))&&P = A && M，Q同理
- 最终我们找到了`F=0`条件K，且!K || P/Q = !K，A && M && K = 0，(A&& (M || N))&&!K = A && M

## 最终代码

```c
#include<stdio.h>
#include<stdlib.h>
long long reverse(long long num,long long ret)
{
    return num==0?ret:reverse(num/10,ret*10+num%10);
}
int isPalindrome1(int x)
{
    long long num = x;
    if(x<0) return 0;
    long long palin = reverse(num,0);
    if(num == (int)palin)     return 1;
    else return 0;
}

/* 32位解法 */
int isPalindrome(int x)
{
	int num=0;

	if(x<0 || x%10==0 && x!=0  ) return 0;
	for(; num < x; x/=10)
		num = num*10 + x%10;
	
	return num == x || num/10 == x;
}
```





