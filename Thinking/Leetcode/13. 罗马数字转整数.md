## 题目描述

罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。

```
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```


例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。

```
示例 1:
输入: "III"
输出: 3
示例 2:
输入: "IV"
输出: 4
示例 3:
输入: "IX"
输出: 9
示例 4:
输入: "LVIII"
输出: 58
解释: L = 50, V= 5, III = 3.
示例 5:
输入: "MCMXCIV"
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.
```

## 题解

​	本题也是简单题，所要做的就是检测字符串然后得到对应数字。关键在于如何检测，罗马数字不同于数学的数字以位数相加， 而是由多个符号组合，最后的值就是这些符号的总和。因此算法需要得到一串字符中的所有符号。

​	题目描述给出了罗马字符所有的符号，且符号最多两个字母，因此直接用暴力法检测所有情况是一种可行题解，虽然依旧有许些麻烦。更简便的方法是观察符号的特性，我们可以发现两个字母符号总是小的字母在左大的在右，而且其值也是大的字母的值减去小的。而且罗马数整体都是大的符号(非大字母)在左，小符号在右。可能想到了将检测符号化为检测字母，但是目前这样仍不能只能以字符检测罗马数字。这是因为我们还没确定罗马数两个符号之间的字母规律。

​	其实思考的越详细就能体会到罗马字符设计的乐趣。罗马数字双字母符号每个字母有且仅有一种，如`M`只有`MC`。而且罗马数字单个字母字符的值始终是最大的，比如`M`>`MC`，`C`>`XC`，当然这说法的不严谨，但不影响解题就行。另外通过上文也知晓了右边的符号又会比左边小。之后来思考罗马数字两个字符字母变化的规律。

​	罗马数字字符之间会出现$A_1A_2B_1B_2$、$AB_1B_2$、$A_1A_2B$，$AB$，四种情况，我们分别讨论，第一种情况因为双字符符号每个字母有且仅有一种，$A_1A_2>B_1B_2$，所以$A_2>B_2$，又因为单个字母字符值是最大的，所以$B_1<B_2<A_2$，同时有$A_1<A_2$，因此我们可以得出第一种情况下的字母规律为 ↑`↓`↑ ，字符交界处的变化高亮显示。再来看看第二种情况，有$A\geq B_2$，所以$B_1<B_2\leq A$，字母规律为 `↓`↑ 。第三种情况有$A_2>B$，同时$A_1<A_2$，所以字母规律为↑`↓`。最后一种情况有$A>B$，字母规律为`↓`。

​	所有情况都讨论了，惊讶的发现字符交界处字母始终是变小的，而且双字符之间的字母始终是变大的，这样就得出了新的以字母变化来判断字符的方法。这里直接结合罗马数字规律来讲解，对于给定的输入字符串，在处理其的一个字母时，若其后面一个字母比它大，那么说明两者是一个字符，因此字符值要减去当前字母的值，又因为罗马数字就是所有字符值的总和，因此直接在总值上减去当前字母的值。若后面一个字母比当前字母小，说明到了字母交界处，当前字母是字符的最大值，因此在总值上加上当前字母的值。而最后一个字母无法与别的字母比较，但其一定是当前字符的最大值，因此加上即可。

​	最后，再进行抽象总结，该题我们将罗马数字化成字符组合的值，又找出了字符内和字符间的字母规律，很幸运的是两者都是一种字母规律且互不相干，一种增大一种减少，这不仅使得判断变得相当容易，也使得需要处理的范围大大减少，在这题种处理范围就是两个字母。若有一个罗马新数字，最多可以三个字符，但如果它们之间仍符合我们发现的数字，那我们的处理范围仍可以保持在两个字母，在循环结束后处理最后一个字母。而如果使用开头提及的暴力法，因为必须要同时处理三个字母，因此循环结束后，可能还需要处理一到两个字母，从头到尾都要十分繁琐。

## 最终代码

```c
int romanToInt(char * s)
{
    int roman[128]={0};
    int index = strlen(s);
    int sum=0,flag=1;
    roman['I']=1;roman['V']=5;roman['X']=10;roman['L']=50;
	roman['C']=100;roman['D']=500;roman['M']=1000;
    
    for(int i=0,tmpp=0,tmpn;i<index;i++){
        tmpn = roman[s[i]];
        flag = tmpn > tmpp? -1 : 1;
        sum += flag * tmpp;
        tmpp = tmpn;
    }    
    sum += roman[s[index-1]];
    return sum;
}
```

