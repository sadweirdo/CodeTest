## 题目描述

给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

注意:假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。

示例 1:

```
输入: 123
输出: 321
```

 示例 2:

```
输入: -123
输出: -321
```

示例 3:

```
输入: 120
输出: 21
```

## 题解

### 1. 直接解

​	本题是Leetcode第二道简单题，若无视题目给出的32位环境限制，那么这道题目非常简单。因为输入是32位数，因此若使用64位变量则永不溢出，从而直接对整数进行反转，反转完成后判断是否大于INT上限即可。这里先无视异号取余规则差异，下文会介绍。

### 2. 溢出判断

​	若要在32位环境下实现，则无法通过与INT_MAX,INT_MIN的比较来判断是否溢出。此时应该要找出代码中可能会产生溢出的地方，在这几行代码前面添加溢出检测。本题下可能会产生溢出的代码仅为`ret = ret*10 + pop`一行。因此添加`ret > INT_MAX/10 || (ret == INT_MAX / 10 && pop > 7`和`ret < INT_MIN/10 || (ret == INT_MIN / 10 && pop < -8`或`ret > (INT_MAX - pop)/10 || ret < (INT_MIN-pop)/10`即可，个人倾向于后者，更益于理解。

​	上述检测适用于所有含有该溢出代码的代码，因为检测条件是通过数学算术表达式得到，因此直接满足所有情况。但由于本题的整数反转特殊性，还可以再度优化，即只需`ret > INT_MAX/10 || ret <INT_MIN/10`。首先要想到溢出的整数位数必须要大于等于INT_MAX[MIN]的位数，又因为32位的限制，因此溢出整数位数与INT_MAX位数一致。再在除去`ret > INT_MAX/10`的情况下只剩下`ret = INT_MAX/10`需要处理，因为ret是int值的反转，所以原本int值也不可能超出INT_MAX，且溢出情况下pop必定是反转整数的最后一位，也是原本int值的第一位，因此只能为1或2。这样pop就不影响算术结果，可以去除。

```c
/* 直接判断溢出 */
int reverse(int x)
{
    int rev = 0;
    while (x != 0) {
        int pop = x % 10;	//不同编程语言负数取余规则不同会导致结果错误
        x /= 10;
        if (rev > INT_MAX/10 || rev < INT_MIN/10) return 0;
        rev = rev * 10 + pop;
    }
    return rev;
}
```

### 3. 字符串转化

​	如果不考虑兼容问题，题解2相当完美。但是不同编程语言如c++/java和python对异号取余的规则不同。编程语言对负数取余遵循公式如下：

```
a与d是整数，d非零，那么余数r满足：a=q*d+r,q为整数，且0<=|r|<|d|
```

​	举例来说，当`-123%10`的时候，c++/java结果是`-3(-12*10+-3)`，而python则是`7(-13*10+7)`。这根本原因在于两者语言对异号除法的算法就不一致。因此为了解决这个不兼容的现象，我们可以对除法和取余分别封装，移植到python时重新实现。也可以将本题int值先化为字符串反转后再化为整数。还有个方法就是将负数化为正数进行取余，但是32位环境下INT_MIN是无法化为正数的，直接的代数运算处理INT_MIN会显得十分繁琐。

​	字符串转化没什么难度，不过作为练习也实现了一个简单的string.h库函数。里面有32位整数与字符串互相转化，简单的strlen和strcmp以及比较数字字符串函数。在整数化为字符串中，也会使用异号除法取余，在这里使用负数化为正数处理，对于`x==INT_MIN`情况直接拷贝数值位INT_MIN的static字符串到参数，相对来说简化了INT_MIN的处理流程。字符串化为整数较为简单，比较对应字符串大小，超出就返回0。

```c
#include<stdio.h>
#include<stdlib.h>
#include"../macro.h"
#include"../string.h" 
/* 假设环境仅能存储32位有符号整数 */

/* 字符串转化 */
int reverse(int x)
{
	char *str;
	int count;
    int num = x,flag;
    
	count = dec_to_str(num ,&flag ,&str);
	if(!count) prt(Error:transfer to string fail);
	for(char i=0,tmp;i<count/2;i++)
		exchange(str[i] ,str[count-1-i] ,tmp)
	return str_to_dec(str,flag);
}
```



