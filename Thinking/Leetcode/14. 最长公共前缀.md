## 题目描述

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 ""。

```
示例 1:

输入: ["flower","flow","flight"]
输出: "fl"
示例 2:

输入: ["dog","racecar","car"]
输出: ""
解释: 输入不存在公共前缀。
```

## 题解

​	虽然是个简单题，但是有很多解题思路，不亚于一道中等题。讲解题解之前必须要骂一下这道题的空输入，仅传入strsSize=0而strs非空非NULL，搞的解题10分钟不到愣是花了一小时排这问题。

### 1. 竖排扫描

​	其他的算法不多讲，直接从竖排开始，竖排就是同时检测每个字符串的某个索引，若都一样，说明这一个字符是这些字符串的公共前缀，继续下一列扫描。时间复杂度`O((n-1)*minlen)`

### 2. 归并

​	用归并思想扫描字符串，学过归并排序这个不难理解，有所遗忘的可以看`Sort/归并.md`。在这里不多说。主要来说一下归并算法的时间复杂度。首先归并算法下，如果`low==right`那么一般会直接返回，而其余情况都需要调用merge()，这会产生一个复杂度的比较。而大小为n的数归并调用merge()的次数是n-1，这样就得到了本算法时间复杂度`O((n-1)*LEN)`，其中LEN大小不一但总有`LEN>=minlen`。所以本题下归并不论时间还是空间复杂度均高于竖排扫描，不过时间复杂度仍处于同一数量级，也可使用但更适合用作归并思想与递归的练习。

​	这里还要说一下因为C语言的简洁，我们无法直接删减添加字符串，而需要重新分配空间。因为本人本着函数不应修改函数输入(注意并非函数所有参数都是输入)的理念，本题在调用merge()时都会使用malloc新分配空间，不会直接修改传入的strs字符串数组。因此为了能及时free掉这些空间，对递归做了一定的变动。这些变动是为了保证递归调用传回来的指针都是malloc分配的，因此我们可以直接在函数末尾free掉这些指针。

​	再往抽象说，想要保证及时free，需要先理解递归的IO。本题递归函数OUTPUT(IO可参见`循环递归队列堆栈.md`)仅有返回值，而且是一个char *指针，我们无法在上层递归函数中识别出来这是题目输入还是malloc生成的，因此我们只有在下层递归函数中保证其返回指向malloc生成区域的指针。因此只需要函数所有的return都需要进行一番检查。

## 最终代码

```c
#include<stdlib.h>
#include"../macro.h"

/* 竖排扫描 */
char * longestCommonPrefix1(char ** strs, int strsSize)
{
	int len = 0;
	
	if(strsSize == 0)  return "";
	
	for(char tmpo,tmp ;strs[0][len] ;len++){
		tmpo = strs[0][len];
		for(int i=0 ;i<strsSize ;i++){
			tmp = strs[i][len];
			if(tmp == '\0' || tmp != tmpo)
				goto OUT;
		}
	}
	
	char *str
OUT:
	str = mlloc(char,len+1);
	memcpy(str,strs[0],len);
	str[len]='\0';
	
	return str;
}

/* 归并 */
char * merge(char *a,char *b)
{
    if(!a || !b)    return NULL;
    
	int len;
    
	for(  ;  ;len++){
		if(a[len]=='\0' || a[len]!=b[len])
			break;
    }
	char *str = mlloc(char,len+1);
	memcpy(str,a,len);
	str[len]='\0';
    
	return str;
}
char * mergecommon(char **str,int low, int high)
{
	char *string;
	if(low > high)	return NULL;
	if(low == high){					//保证left和right都是函数内部malloc分配的内存，可以释放
		string = mlloc(char,strlen(str[low])+1);
		memcpy(string,str[low],strlen(str[low])+1);
		return string;
	}		
	if(high == low+1)	return merge(str[low],str[high]); //这里并非再为了保证malloc，而是为了避免
																		//下方再次递归的开销(包括lowhigh变量相等重新malloc)
	char *left,*right;		
	int mid = (low+high)/2;
	left = mergecommon(str,low,mid);	//递归执行到此可以保证变量指向的是新malloc分配的而非str递归参数
	right = mergecommon(str,mid+1,high);
	
	string = merge(left,right);
	free(left); free(right);
	return string;
}
char * longestCommonPrefix(char ** strs, int strsSize)
{
	if(strsSize==0) return "";
	return mergecommon(strs,0,strsSize-1);
}
```

