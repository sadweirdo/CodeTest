# 归并排序

## 前言

- 数据结构系列文章代码实现部分,将关键处理代码简写为处理代码

## Ⅰ. 思想

​	归并排序有两种想法，但本质上都一样，都是由两个有序数列合并成一个大数列。

- 自顶向下

  ​	自顶向下思想将需要排序的数列拆分成大小相近的两组，再顺序比较两组数列的数值，将其合并成一个有序数列。该类思想关键在于如何高效比较两组数列，不难想到如果两组数列皆为有序数列，即两个数列里数值依次增大，我们便可以从头到尾遍历数列，按从小到大的方式不断挑选出依次增大的值组成新的数列，当所有值都挑选完毕后就形成所需的有序数列。

  ​	然而数列本身无序，拆分成的两组数列极大概率也无序，如何使其保持有序？对此利用递归思想，继续拆分已经拆分的两组数列，并且只要不断拆分新得到的数列，最终一定会得到数值数量仅为1的数列，这个数列自然是有序的。可以想到当某个数列数值数量为2时，其会被拆分为两个数值数量为1的数列，此时便满足了两数列皆为有序数列的条件，可以将其组成数值数量为2的有序数列，再将其与另一个经此方法形成的有序数列组合成数值数量为4的有序数列，依次组合下去最终形成需要的有序数列。这就是归并。

  ​	自顶向下方法从需求点进行思考，符合大多人思考的方向，但其的递归思想使人不能即刻想到整个计算的计算

- 自底向上

  ​	自底向上直接从两个数值数量为1的数列开始，将其合并成数量为2的数列，再依次不断合并得到最终的有序数列。

  ​	自底向上思想通常是理解自顶向下后在重新思考归并排序所得，而自顶向下最终也是借由自底向上实现的，两者互相关联。

## Ⅱ. 代码实现

### 2.1 函数结构

#### 自顶向下

1. 确定关键处理步骤

   归并排序关键步骤在于数列的合并，依次从头到尾顺序比较两个数列数值，将其合并成为大数列。因为该关键处理步骤有一定代码量，调用频繁，因此将其封装为函数merge()。 

2. 明确控制流(调用次数和条件)

   自顶向下归并排序控制流关键为数列的递归拆分，并且调用处理代码前需要保证两个数列皆为有序，因此采用后序递归。再进行处理代码前两次调用归并排序排序两个数列，确保合并前两数列已有序。当需要排序的数列大小仅为一时函数返回。当两个小数列的归并排序函数都返回后，即可执行处理代码归并两个小数列。

#### 自底向上

1. 确定关键处理步骤

   归并排序关键步骤在于数列的合并，依次从头到尾顺序比较两个数列数值，将其合并成为大数列。因为该关键处理步骤有一定代码量，调用频繁，因此将其封装为函数merge()。 此函数两种思想下实现一致。

2. 明确控制流(调用次数和条件）

   自底向上归并排序控制流关键在于以小到大组合成有序数列，并且在组合大数列前需要两个小数列皆有序。因此我们需要从小数列开始由小到大一层层将其合并，即先将所有大小为1的有序数列两两分组，合并成大小为2的小数列，再分组并合并成大小为4的数列，以此循环。

   自底向上可以采用循环实现层次合并，首先需要一个大循环实现层次由小到大的遍历，首先合并成大小为2的数列，每轮循环合并大小为之前的两倍，在每个大循环里还需要一个循环完成单个层次之间所有小数列的各自合并。我们就在小循环里调用处理代码完成两个小数列的合并。

   ps:若选择排序完两个小数列就合并成大数列，并且合并完另一个大数列后就立即与之前大数列合并成一个更大数列...。如此当然也是符合自底向上的，但是在程序中此类控制流就是由后序递归所实现的，循环无法实现此类控制流(也许可以，才学疏浅未曾了解到)。

### 2.2 接口设计

​	归并排序分为排序函数sort()，数列合并函数merge()，其中merge()为sort()内置关键处理函数。下面给出int数组数据结构下的函数接口设计，其中递归函数下为了提高性能在sort()函数中增加了temp数组参数。

```c
/* num:待排序数组  temp:临时存放数据数组(该参数只限于递归实现下) */
/* left、right:排序范围，值为排序数组索引                      */
sort(int *num , int left , int right [, int *temp])
 
/* num:待排序数组  temp:临时存放数据数组      				  */
/* left、right:数列合并范围，值为排序数组索引  				    */
/* mid:数列分界点，值代表第一个数组末尾，非常重要，详见边界条件一节 */
merge(int *num , int left , int mid , int right , int *temp)
```

### 2.3 边界条件

#### 合并数列未处理完部分

​	若一个数列已经被挑选完毕，另一个数列还有剩余，由于此时该剩余部分肯定大于等于之前已挑选的所有数值，且剩余部分仍然由小到大有序排列，因此只需将该未处理完数列所有剩余值依次增加到临时数列后面即可。

#### 完整遍历数列

​	该问题为编程基础边界条件，在一般遍历数组的循环中，由于数组由下标从0开始，我们常设定下标变量i初始值为0，并添加判断条件i<n确保i在循环内最大值为n-1，不会产生数组越界访问。而在归并排序中，所有参数值直接是数组下标，因此我们无需防范上述情况，所有循环判断皆可使用<=以便完整遍历数列。

#### 非二n次幂数量数列

- 自顶向下

  递归处理时非二n次幂数量数列将被划分成若干个大小为3的数列和大小为2的数列，其中大小为3的数列会继续拆分成大小为1的数列与大小为2的数列的合并。其仍满足处理代码的前置要求，因此无需额外操作来保证排序正确性。

- 自底向上

  循环处理非二n次幂数量数列时，由于大循环合并大小初值为2且每轮循环值*2，因此每轮小循环合并的都是$2^n$大小数列，当小循环处理到该层最后一组数列时，数列首端加上大循环的处理大小便会超过数组范围，因此每次调用merge函数前我们需要检测排序范围，当超出范围时修改范围到数组最后一个数。

  除此之外，当大循环合并大小超过非二n次幂数量数列大小时，数列还有最后一层合并没有进行，为此，我们可以额外执行一次merge函数，也可以修改检测范围，将其从i<n变为i<n*2，n为数组大小，n\*2即让检测值也进行一轮循环后处理，这样一来循环检测就会多进行一轮，循环自然也会多进行一轮。

#### 合并中值的计算

​	merge()函数接口中有mid，尽管它的计算是固定的"$(left+right)/2$"，但其并非一个多余的值，而是给予merge函数的设计理念所设置的。

​	merge()函数作用为合并两个数列，前提是两函数已经有序。但在归并函数处理中merge()函数并不会检测两个数列是否有序，它选择完全相信sort()函数。如果取消mid参数，而在merge函数里使用 "$mid = (left+right)/2; $" 来计算得到mid值。乍看下去并没有问题，事实上在递归处理下取消mid值也并没有关系。

​	但在循环处理便出现了问题，比如若需要排序大小为13的数列，由于数列为非$2^n$大小数列，因此调用merge合并数列前有范围检测，若right值被修正为数组大小，那么在merge里面计算出的mid值已不再是第一个数组的末尾，left-mid体现的数列不再是一个$2^n$大小数列，而mid+1-right(n-1)数列就不再是个有序数列(这种情况下计算出的mid总是小于正常的mid)，但merge函数依然将两个数列当成有序数列处理，此时合并的数列就十分有可能出错。为了避免这样的情况，我们还需在小循环调用处理函数merge前根据大循环处理大小计算好mid值传入merge函数。

​	最后我们来想一下为什么递归处理没有该问题，顺带理解递归和循环处理的区别。前文我们可以明白该问题出现的根本原因在于right值被修正导致merge对两个有序数列的划分出现了问题，而修正right值又是为了避免数组越界。即自底向上归并无法控制确定的大小而只能以$2^n$大小进行扩充。而递归处理一开始就给定了最大范围，我们所做的就是一直拆分成两个大小相近的数组，因此merge合并的两个数列始终保持各自有序，从而避免该问题的出现。该问题上我们还可以看到递归和循环实现归并时不仅处理顺序有差异，就连同一层次的排序范围也是不同的，循环某个层次间始终处理大小为$2^n$次幂的数列，而递归则有可能处理这奇数大小的数列。