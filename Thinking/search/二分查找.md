## 二分查找

​	要使用二分查找除了满足查找的基本要求外，查找对象需要有序。

​	广义的二分查找即递归查找上次的一半的元素，因此二分查找必然是个循环，至于递归还是循环实现看个人喜好。循环必然涉及到循环条件，对二分查找不熟练的人往往在思考时会陷入循环内处理的思考，只想到如果大于会怎样，小于会怎样，但这只是循环的处理方式而非循环条件。

​	二分查找的循环条件通常是`low<high`，同时用`mid = (low + high)/2`界定一半元素，判断时使用mid判断，根据判断结果继续递归处理一半元素。本人学习中，二分查找是第一次引入low,high的算法，个人觉得这个终止条件的设置非常出色。当学会二分查找时感觉理所当然，然而前阵子长时间没接触代码后回过头来自己却没有想到。

​	二分查找通常形容有序数组的查找，但我们可以提取其思想。如果所求数据在数组或线性数据结构中存在，那么我们就可以用low,high对所求数据进行界定。如果所求数据可以通过二元判断式(即只有两种情况)判断，那我们就可以用二分查找来代替遍历节省时间复杂度，此时low,high将转化为循环条件，循环结束时它们值即为所求数据的位置。注意这里的二元判断式，只要判断结果仅有两种即可，而判断过程可以是一行代码也可以是一个函数。

​	本文二分查找仅限于查找单个数据，像`Leetcode/14.最长公共前缀`一题虽然返回字符串，但二分查找是找最后一个存在的字符，因此也适用于本文的情况。二分查找有以下几种可行情况：

```
while(low<high){
    if(A)	low = mid+1;
    else	high = mid;
}//no.1
while(low<high){
    if(A)	high = mid;
    else	low = mid+1;
}//no.2
while(low<=high){
    if(A)	high = mid-1;
    else	low = mid+1;
}//no.3
while(low<=high){
    if(A)	low = mid+1;
    else	high = mid-1;
}//no.4
while(low<high){
    if(A)	low = mid+1;
    else	high = mid-1;
}//no.5
while(low<high){
	if(A)	high = mid-1;
	else	low = mid+1
}no.66
```

​	可以看到，no.1和no.2是一样的，no.3和no.4，no.5和no.6是一样的。首先分析`low=mid+1`，这在所有方法里都一致，而`low=mid`不可取是因为当`low+1=high`时`low = mid`，因此此时函数可能会陷入`low = mid`死循环，也许你可以设置A使其避免这种情况，但这不符合二分查找的设计理念，只会多增开销。二分查找中A已经对mid进行了检测，`low=mid+1`并不会遗漏数据，`high=mid-1`同理。

​	若查找的线性数据中存在有效数据，那么三个查找方法都能正常工作。但若查找的线性数据中没有所求数据，假设A,B分别是线性数据中最接近所求数据的左右两个数据，那么no.3方法会返回`high = A，low=A+1=B`的结果，而no.1会返回`high = low = B`的结果。

​	当数据不存在并且此时不论low，high如何变化，判断式`A`都只会一直返回某一值譬如真的时候，二分查找将会返回边界值，no.3会分别返回`high=-1`或`low=max+1`(max为数据最大索引)，因此no.3可根据返回值直接判断给定的数据区间是否存在所求数据，而no.1会返回0和max，还需要再进行数据有效性检测。

​	基于上述这两个特点，可以根据需求来选择使用，至于no.5，其的返回不确定，有可能`low=high`，又有可能`high=low-1`。因此不推荐使用。最后，推荐使用no.3，只要不是强求边界值必须在有效索引内的话，no.3的low，high指针可以直接满足所有二分查找方法中最多的需求。

