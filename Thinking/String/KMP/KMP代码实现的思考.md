​	编程功底不够时，对于比较复杂的算法思想，要将其用代码实现往往很困难，因此也就有了本文，记录代码实现KMP时的一点思考。别的不多说，先贴上代码：

```c
/*	KMP算法	*/

/*		创建next数组，索引0开始		*/
static inline int *_kmp_createnext(char *tar, int tarcnt)
{
	int *next = calloc(tarcnt,sizeof(int));
	if(tarcnt == 1) return next;
	int i = 1;		//i代表后子串中最后一个待匹配的字符，同时是字符串遍历索引
	int k = 0;		//k代表前子串中最后一个待匹配的字符
	
	/*	next[0]=next[1]=0，因为calloc申请所以没有省略赋值 */
	while(i<tarcnt-1){
		if(tar[i] == tar[k])
			next[++i] = ++k;	//next数组索引是不匹配字符位置，因此要++i。
											//next值是待匹配字符位置，因此要++k。
		else if(k==0)   next[++i]=0; 	//排除下面这种情况可能会出现的无限循环
        else
			k = next[k];
	}
	return next;
}

/*		KMP搜索		*/
static inline int _kmp_search(char *src, int srccnt, char *tar, int tarcnt, int *next)
{
	int i,j;
	for(i=0, j=0  ;i<srccnt && j<tarcnt;){
		 if(src[i]==tar[j]){
			 i++;j++;
		 }
		 else if(j==0)	i++; 	//排除下面这种情况可能会出现的无限循环
		 else
				j=next[j];
	}
	if(j == tarcnt)		return i-j;
	else return -1;
}

/*		KMP算法接口函数	*/
int kmp_searchstr(char *src, int srccnt, char *tar, int tarcnt)
{
	if(tarcnt == 0)	return 0;
	if(tarcnt > srccnt)	return -1;
	int *next = _kmp_createnext(tar,tarcnt);
	if(!next){
		printf("Error: next array create failed!\n");
		return -1;
	}
	return _kmp_search(src,srccnt,tar,tarcnt,next);
}
```



​	首先是接口设计，KMP算法大步骤很明显，需要先建立next数组然后搜索，这里将两个步骤各自设计成一个函数，然后用一个包装后作为算法的接口。函数参数虽然琐碎了点但也很明了，不多说了。

​	然后依次来讨论两个步骤的编程思路，先说第一个`_kmp_search()`：

- 很明显函数会使用循环，照常用i表示源串索引，j表示模式串索引，很明显i<srccnt，j<tarcnt都是循环的检测条件，并且当循环结束后j==tarcnt时说明匹配成功，不等则匹配失败。因此我们得到了函数的控制流(循环)，和函数返回阶段的判断控制流。
- 思考是否需要循环嵌套，发现i，j的循环部分不需要分开处理，同时因为循环也不能化为标准的for形式，用两个while不如合并成一个while（代码里用的for），因此采用一个循环
- 理解透彻KMP的比较过程后会发现：当字符不匹配时，源串始终只需处理不匹配的位置，而模式串会依据next数组值不断缩短，因此循环过程i是顺序的，KMP的搜索过程形式是上条中的后者，且i，j之间没有很强的层次性，即对每个i而言j变化不一定，对比简单搜索中每个i，j都要遍历一次。因此采用一层循环实现，循环检测条件为`i<srccnt && j<tarcnt`
- 循环内处理只有匹配成功和失败两种情况，匹配成功即代码中第一个情况比较简单，匹配不成功时通常是代码中第三种情况，j代表模式串中不匹配的位置，是next数组的索引，取出来的值也是新的待匹配位置。然后便进入下次循环重新匹配，这次循环中i的位置不变。
- 循环内还有第二种情况是比较特殊的，根本原因是本人将next数组的数值设置在0-N-1，即始终代表着有效的坐标索引，这样因为j和next[j]值都有可能是0，且该情况处理没有改变i变量的值，将可能会出现无限循环，必须用第二种情况来处理避免。也可将next[0]设为-1，并将j=-1纳入第一种处理情况，这样就可以省去代码种的第二种处理。
- 成功返回时字符串必然匹配完成，因此可直接使用i，j变量返回无需额外辅助变量

之后来说最重要的`_kmp_createnext()`：

- 用编程实现建立next数组函数最重要的是要理解透彻next数组建立过程，不要将其与源码比较搞混，仅仅抓住前后子串进行处理。处理过程中，后子串和源串一样具有不匹配时位置不变的特点，称为不变待匹配位置，而前子串和模式串一样会不断改变待匹配位置。
- 在编程实现种最关键的一步是确定好使用的变量和控制流，本函数前后子串和next数组都需要一个索引变量。完成该步骤的关键是达成上一条的要求，即理解透彻next数组建立过程。否则连前后子串都想不到，基本的索引变量数量和意义都无法确定。函数控制流很简单，依然是循环，依次处理完next数组所有元素即可。
- 有了索引变量，就需要确定处理的数组位置与索引变量的关系，看能否直接使用索引变量，省去其他的辅助变量。其中后子串的最后一个字符每次循环都会向后移动一位，这刚好和next数组得变化一致，思考后发现两者位置也始终相差1，因此可以直接使用一个变量i表示两个索引(如果没有理解透彻，往往会将其和前子串搞混)。
- 一开始最好不要关注边界条件，包括初始元素和越界。先写出大致框架，我们用k表示前子串得待匹配位置，每次k都要和后子串不变待匹配位置比较，因此直接将i设置为后子串不匹配位置，然后得到了判断条件`src[i]==tar[k]`，此时就得到了新的next值，因为k代表的是旧next值，所以新next值为k+1，然后新next值得索引是i+1，因此直接递增i，k再赋值。如果不相等就需要改变K得值，依旧从next数组中取值。这样大致框架都完成了。
- 现在要考虑边界条件，首先初始化next[0]肯定不用说，next[1]思考一下也肯定为0，这里要注意字符串长度，如果仅为1就没必要处理next[1]。所以循环直接从next[2]开始，将i，k分别初始化为1，0，代表最初的后子串不变待匹配位置和最初的前子串匹配位置。之后要考虑越界，因为相等时先递增了i，k，所以在i=tarcnt-1时，next[++i]就会产生溢出。因此想到将循环条件设为`i<tarcnt-1`，但这需要考虑i=tarcnt-1时的情况，i是后子串的不变待匹配位置，i=tarcnt-1说明在求匹配范围=tarcnt（匹配范围从1开始）的最大相同前后子串长度，但这时代表字符串已经匹配成功，没有再求next数组的需求。因此循环条件成立
- 最后来看些其他情况，首先是循环中第二个处理情况，这个上一个函数情况一致，都是为了防止无限循环，可以设置next[0]=-1来将其并入第一种处理情况。然后是如果将i设置为next索引，函数要怎么改变。这里需要将src[i]变为src[i-1]，++i变为i++，但是不能将i++加入for内，这是因为有第三种情况不改变i的值。因此往后有循环结构，优先以while方式思考，确定一次循环处理一定能做的处理后再将其加入for。